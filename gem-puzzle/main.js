/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var time = document.getElementById(\"time\");\nvar movesBlock = document.getElementById(\"moves\");\nvar arr = [], box, ei, ej;\nvar min = 0;\nvar sec = 0;\nvar moves = 0;\nvar goalArr = [];\nvar checkbox = document.getElementById(\"checkbox\");\nvar box = document.getElementById(\"id\");\nvar startDradr = false;\nvar isStop = true;\n\nfunction addZero(n) {\n\treturn (parseInt(n, 10) < 10 ? '0' : '') + n;\n}\n\nfunction addZeroMin(n) {\n\treturn (parseInt(n, 10) < 10 ? '0' : '') + n;\n}\n\nfunction swap(arr, i1, j1, i2, j2) {\n\tt = arr[i1][j1];\n\tarr[i1][j1] = arr[i2][j2];\n\tarr[i2][j2] = t;\n}\nwindow.onload = function () {\n\tbox = document.getElementById(\"box\");\n\tnewGame();\n\tsetInterval(showTime, 1000);\n\tdocument.getElementById(\"reset\").onclick = newGame;\n\tdocument.getElementById(\"reset2\").onclick = newGame;\n\tdocument.getElementById(\"save\").onclick = save;\n\tdocument.getElementById(\"load\").onclick = load;\n}\n\nfunction save() {\n\tlocalStorage.setItem(\"game\", box.innerHTML);\n\tlocalStorage.setItem(\"arr\", arr);\n\tlocalStorage.setItem(\"ei\", ei);\n\tlocalStorage.setItem(\"ej\", ej);\n\tlocalStorage.setItem(\"moves\", moves);\n\tlocalStorage.setItem(\"min\", min);\n\tlocalStorage.setItem(\"sec\", sec);\n}\n\nfunction load() {\n\n\tif (localStorage.getItem(\"game\") != null) {\n\t\tmin = localStorage.getItem(\"min\");\n\t\tsec = localStorage.getItem(\"sec\");\n\t\tshowTime();\n\t\tvar movesBlock = document.getElementById(\"moves\");\n\t\tmoves = localStorage.getItem(\"moves\");\n\t\tmovesBlock.innerHTML = moves;\n\t\tei = localStorage.getItem(\"ei\");\n\t\tej = localStorage.getItem(\"ej\");\n\t\tbox.innerHTML = localStorage.getItem(\"game\");\n\t\tvar larr = localStorage.getItem(\"arr\").split(\",\");\n\t\tarr = [\n\t\t\t[larr[0], larr[1], larr[2], larr[3]],\n\t\t\t[larr[4], larr[5], larr[6], larr[7]],\n\t\t\t[larr[8], larr[9], larr[10], larr[11]],\n\t\t\t[larr[12], larr[13], larr[14], larr[15]],\n\t\t];\n\t\tvar cells = [...document.getElementsByTagName(\"td\")];\n\t\tfor (let i = 0; i < cells.length; i++) {\n\t\t\tcells[i].onclick = cellClick;\n\t\t}\n\n\n\t}\n\telse {\n\t\talert(\"Нет сохранённых игр!\");\n\t}\n}\n\nfunction cellClick(event) {\n\tvar event = event || window.event,\n\t\tel = event.srcElement || event.target,\n\t\ti = el.id.charAt(0),\n\t\tj = el.id.charAt(2);\n\tif ((i == ei && Math.abs(j - ej) == 1) || (j == ej && Math.abs(i - ei) == 1)) {\n\t\tvar startPosition = offset(el);\n\t\tvar end = false;\n\t\tel.style.top = startPosition.top;\n\t\tif (i > ei) {\n\t\t\tvar pos = 0;\n\t\t\tvar id = setInterval(frame, 1);\n\t\t\tfunction frame() {\n\t\t\t\tif (pos == 70) {\n\t\t\t\t\tend = true;\n\t\t\t\t\tclearInterval(id);\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tel.style.position = \"static\";\n\t\t\t\t\tel.style.left = '0';\n\t\t\t\t\tel.style.top = \"0\";\n\t\t\t\t\tel.style.bottom = \"0\";\n\t\t\t\t} else {\n\t\t\t\t\tpos++;\n\t\t\t\t\tel.style.position = \"absolute\";\n\t\t\t\t\tel.style.left = 'auto';\n\t\t\t\t\tel.style.top = (Number(el.style.top.slice(0, -2)) - 1) + \"px\";\n\t\t\t\t\tel.style.bottom = \"auto\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (i < ei) {\n\t\t\tvar pos = 0;\n\t\t\tvar id = setInterval(frame, 1);\n\t\t\tfunction frame() {\n\t\t\t\tif (pos == 50) {\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tel.style.position = \"static\";\n\t\t\t\t\tel.style.left = '0';\n\t\t\t\t\tel.style.top = \"0\";\n\t\t\t\t\tel.style.bottom = \"0\";\n\t\t\t\t\tclearInterval(id);\n\t\t\t\t} else {\n\t\t\t\t\tpos++;\n\t\t\t\t\tel.style.position = \"absolute\";\n\t\t\t\t\tel.style.left = 'auto';\n\t\t\t\t\tel.style.top = (Number(el.style.top.slice(0, -2)) + 1) + \"px\";\n\t\t\t\t\tel.style.bottom = \"auto\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tel.style.left = startPosition.left;\n\t\t\tif (j > ej) {\n\t\t\t\tvar pos = 0;\n\t\t\t\tvar id = setInterval(frame, 1);\n\t\t\t\tfunction frame() {\n\t\t\t\t\tif (pos == 50) {\n\t\t\t\t\t\tpos = 0;\n\t\t\t\t\t\tel.style.position = \"static\";\n\t\t\t\t\t\tel.style.left = '0';\n\t\t\t\t\t\tel.style.top = \"0\";\n\t\t\t\t\t\tel.style.bottom = \"0\";\n\t\t\t\t\t\tclearInterval(id);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t\tel.style.position = \"absolute\";\n\t\t\t\t\t\tel.style.top = \"auto\";\n\t\t\t\t\t\tel.style.left = (Number(el.style.left.slice(0, -2)) - 1) + \"px\";\n\t\t\t\t\t\tel.style.bottom = \"auto\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j < ej) {\n\t\t\t\tvar pos = 0;\n\t\t\t\tvar id = setInterval(frame, 1);\n\t\t\t\tfunction frame() {\n\t\t\t\t\tif (pos == 50) {\n\t\t\t\t\t\tpos = 0;\n\t\t\t\t\t\tel.style.position = \"static\";\n\t\t\t\t\t\tel.style.left = '0';\n\t\t\t\t\t\tel.style.top = \"0\";\n\t\t\t\t\t\tel.style.bottom = \"0\";\n\t\t\t\t\t\tclearInterval(id);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t\tel.style.position = \"absolute\";\n\t\t\t\t\t\tel.style.top = \"auto\";\n\t\t\t\t\t\tel.style.left = (Number(el.style.left.slice(0, -2)) + 1) + \"px\";\n\t\t\t\t\t\tel.style.bottom = \"auto\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsetTimeout(function () {\n\t\t\tvar audio = new Audio();\n\t\t\tif (!audio) return;\n\t\t\taudio.currentTime = 0;\n\t\t\taudio.src = \"./assets/kubik.mp3\";\n\t\t\taudio.play();\n\t\t\tvar movesBlock = document.getElementById(\"moves\");\n\t\t\tmoves++;\n\t\t\tmovesBlock.innerHTML = moves;\n\t\t\tvar oldStyle = el.style.backgroundPosition;\n\t\t\tvar oldStyle2 = document.getElementById(ei + \" \" + ej).style.backgroundPosition;\n\t\t\tdocument.getElementById(ei + \" \" + ej).innerHTML = el.innerHTML;\n\t\t\tdocument.getElementById(ei + \" \" + ej).style.backgroundPosition = oldStyle;\n\t\t\tel.style.backgroundPosition = oldStyle2;\n\t\t\tel.innerHTML = \"\";\n\t\t\tei = i;\n\t\t\tej = j;\n\t\t\tvar q = true;\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tfor (j = 0; j < 4; ++j)\n\t\t\t\t\tif (i + j != 6 && document.getElementById(i + \" \" + j).innerHTML != i * 4 + j + 1) {\n\t\t\t\t\t\tq = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\tif (q) {\n\t\t\t\tvar time = document.getElementById(\"time\");\n\t\t\t\tvar movesBlock = document.getElementById(\"moves\");\n\t\t\t\tvar congratulations = document.querySelector(\".congratulations\");\n\t\t\t\tvar modalBlock = document.querySelector(\".modal-block\");\n\t\t\t\tvar overlay = document.querySelector(\".overlay\");\n\t\t\t\tvar topTable = document.querySelector(\".top-table\");\n\t\t\t\tcongratulations.innerHTML = `Ура! Вы решили головоломку за ${time.innerHTML} и ${moves} ходов`;\n\t\t\t\tcongratulations.style.display = \"inline\";\n\t\t\t\toverlay.style.display = \"block\";\n\t\t\t\tmodalBlock.style.display = \"flex\";\n\t\t\t\tvar myopacity = 0;\n\n\t\t\t\tfunction MyFadeFunction() {\n\t\t\t\t\tif (myopacity < 1) {\n\t\t\t\t\t\tmyopacity += .075;\n\t\t\t\t\t\tsetTimeout(function () { MyFadeFunction() }, 100);\n\t\t\t\t\t}\n\t\t\t\t\tdocument.querySelector('.modal-block').style.opacity = myopacity;\n\t\t\t\t}\n\n\t\t\t\tMyFadeFunction();\n\t\t\t\tvar prioritet = moves;\n\t\t\t\tgoalArr.unshift(prioritet);\n\t\t\t\tif (goalArr.length > 10) {\n\t\t\t\t\tgoalArr.pop();\n\t\t\t\t}\n\t\t\t\tgoalArr.sort();\n\t\t\t\ttopTable.innerHTML = \"\";\n\t\t\t\ttopTable.innerHTML += \"<h5>Results:</h5>\";\n\t\t\t\tfor (let i = 0; i < goalArr.length; i++) {\n\t\t\t\t\ttopTable.innerHTML += `<p>${goalArr[i]}</p>`;\n\t\t\t\t}\n\t\t\t\tlocalStorage.setItem(\"results\", goalArr);\n\t\t\t}\n\t\t}, 250);\n\t}\n}\nfunction newGame() {\n\tvar answer = document.getElementById(\"answer\");\n\tanswer.innerHTML = \"Узнать ответ\";\n\tisStop = true;\n\tvar topTable = document.querySelector(\".top-table\");\n\tif (localStorage.getItem(\"results\") != null && topTable.childElementCount <= 1) {\n\t\tgoalArr = localStorage.getItem(\"results\").split(\",\");\n\t\tfor (let i = 0; i < goalArr.length; i++) {\n\t\t\ttopTable.innerHTML += `<p>${goalArr[i]}</p>`;\n\t\t}\n\t}\n\tvar time = document.getElementById(\"time\");\n\tvar movesBlock = document.getElementById(\"moves\");\n\tvar congratulations = document.querySelector(\".congratulations\");\n\tvar modalBlock = document.querySelector(\".modal-block\");\n\tvar overlay = document.querySelector(\".overlay\");\n\tcongratulations.style.display = \"none\";\n\toverlay.style.display = \"none\";\n\tmodalBlock.style.display = \"none\";\n\tvar time = document.getElementById(\"time\");\n\tvar movesBlock = document.getElementById(\"moves\");\n\tmin = 0;\n\tsec = 0;\n\tmoves = 0;\n\ttime.innerHTML = \"00:00\";\n\tmovesBlock.innerHTML = \"0\";\n\tfor (i = 0; i < 4; ++i) {\n\t\tarr[i] = []\n\t\tfor (j = 0; j < 4; ++j) {\n\t\t\tif (i + j != 6) {\n\t\t\t\tarr[i][j] = i * 4 + j + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tarr[i][j] = \"\";\n\t\t}\n\t}\n\tei = 3;\n\tej = 3;\n\n\tfor (i = 0; i < 1600; ++i)\n\t\tswitch (Math.round(3 * Math.random())) {\n\t\t\tcase 0: if (ei != 0) swap(arr, ei, ej, --ei, ej); break; // up\n\t\t\tcase 1: if (ej != 3) swap(arr, ei, ej, ei, ++ej); break; // right\n\t\t\tcase 2: if (ei != 3) swap(arr, ei, ej, ++ei, ej); break; // down\n\t\t\tcase 3: if (ej != 0) swap(arr, ei, ej, ei, --ej); // left\n\t\t}\n\tvar table = document.createElement(\"table\"),\n\t\ttbody = document.createElement(\"tbody\");\n\ttable.appendChild(tbody);\n\tvar bpos = 58;\n\tvar bpos2 = 222;\n\tvar random = Math.round(Math.random() * 150);\n\tfor (i = 0; i < 4; ++i) {\n\t\tvar row = document.createElement(\"tr\");\n\t\tfor (j = 0; j < 4; ++j) {\n\t\t\tvar cell = document.createElement(\"td\");\n\t\t\tcell.id = i + \" \" + j;\n\t\t\tcell.onclick = cellClick;\n\t\t\tcell.innerHTML = arr[i][j];\n\t\t\tif (cell.innerHTML == \"1\" || cell.innerHTML == \"2\" || cell.innerHTML == \"3\" || cell.innerHTML == \"4\") {\n\t\t\t\tbpos2 = 222;\n\t\t\t\tcell.style.backgroundPosition = `-${bpos * (cell.innerHTML - 1)}px ${bpos2}px`;\n\t\t\t}\n\t\t\tif (cell.innerHTML == \"5\" || cell.innerHTML == \"6\" || cell.innerHTML == \"7\" || cell.innerHTML == \"8\") {\n\t\t\t\tbpos2 = 167;\n\t\t\t\tcell.style.backgroundPosition = `-${bpos * (cell.innerHTML - 5)}px ${bpos2}px`;\n\t\t\t}\n\t\t\tif (cell.innerHTML == \"9\" || cell.innerHTML == \"10\" || cell.innerHTML == \"11\" || cell.innerHTML == \"12\") {\n\t\t\t\tbpos2 = 107;\n\t\t\t\tcell.style.backgroundPosition = `-${bpos * (cell.innerHTML - 9)}px ${bpos2}px`;\n\t\t\t}\n\t\t\tif (cell.innerHTML == \"13\" || cell.innerHTML == \"14\" || cell.innerHTML == \"15\") {\n\t\t\t\tbpos2 = 53;\n\t\t\t\tcell.style.backgroundPosition = `-${bpos * (cell.innerHTML - 13)}px ${bpos2}px`;\n\t\t\t}\n\t\t\tif (cell.innerHTML == \"\") {\n\t\t\t\tcell.style.backgroundPosition = `-400px 53px`;\n\t\t\t}\n\t\t\tcell.style.backgroundImage = `url(./assets/${random}.jpg)`;\n\t\t\tcell.style.backgroundSize = \"230px\";\n\n\t\t\trow.appendChild(cell);\n\n\t\t}\n\n\t\ttbody.appendChild(row);\n\t}\n\tif (box.childNodes.length == 1)\n\t\tbox.removeChild(box.firstChild);\n\tbox.appendChild(table);\n}\n\nfunction showTime() {\n\tvar time = document.getElementById(\"time\");\n\ttime.innerHTML = `${addZeroMin(min)}<span>:</span>${addZero(sec)}`;\n\tsec++;\n\tif (sec === 60) {\n\t\tsec = 0;\n\t\tmin++;\n\t}\n}\n\nvar checkbox = document.getElementById(\"checkbox\");\ncheckbox.onclick = function () {\n\tstartDradr = checkbox.checked;\n\tif (startDradr) {\n\t\tvar cells = [...document.getElementsByTagName(\"td\")];\n\t\tfor (let i = 0; i < cells.length; i++) {\n\t\t\tvar cell = cells[i];\n\t\t\tcell.onmousedown = function (e) {\n\t\t\t\tif (e.target.innerHTML != \"\" && startDradr) {\n\t\t\t\t\tvar startPositions = offset(e.target);\n\n\t\t\t\t\te.target.style.position = 'absolute';\n\t\t\t\t\tmoveAt(e);\n\n\t\t\t\t\te.target.style.zIndex = 1000;\n\n\t\t\t\t\tfunction moveAt(e) {\n\t\t\t\t\t\te.target.style.left = e.pageX - e.target.offsetWidth / 2 + 'px';\n\t\t\t\t\t\te.target.style.top = e.pageY - e.target.offsetHeight / 2 + 'px';\n\t\t\t\t\t}\n\n\t\t\t\t\tdocument.onmousemove = function (e) {\n\n\t\t\t\t\t\tmoveAt(e);\n\t\t\t\t\t}\n\n\t\t\t\t\tcell.onmouseup = function () {\n\t\t\t\t\t\tdocument.onmousemove = null;\n\t\t\t\t\t\te.target.onmouseup = null;\n\t\t\t\t\t\te.target.style.position = \"static\";\n\t\t\t\t\t\tif ((e.target.style.top + 60) < startPositions.top && (e.target.style.top - 60) > startPositions.top) {\n\t\t\t\t\t\t\te.target.click();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcell.ondragstart = function () {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nfunction offset(el) {\n\tvar rect = el.getBoundingClientRect(),\n\t\tscrollLeft = window.pageXOffset || document.documentElement.scrollLeft,\n\t\tscrollTop = window.pageYOffset || document.documentElement.scrollTop;\n\treturn { top: rect.top + scrollTop, left: rect.left + scrollLeft }\n}\n\n//------------------------------------------------------------------------------------------------------------------------|\n\nvar answer = document.getElementById(\"answer\");\n\nanswer.onclick = function () {\n\tisStop = !isStop;\n\tif (isStop) {\n\t\tanswer.innerHTML = \"Узнать ответ\";\n\t} else {\n\t\tanswer.innerHTML = \"Остановить\";\n\t}\n\n\t// NPuzzleSolver\n\t// by Zachary Cava\n\t// repository: https://github.com/technogeek00/NPuzzleSolver\n\n\tfunction NPuzzleSolver(toSolve) {\n\t\tthis.grid = [];\n\t\tthis.fixed = [];\n\t\tthis.numbers = [];\n\t\tthis.solution = [];\n\t\tthis.originalGrid = toSolve;\n\t}\n\n\tNPuzzleSolver.prototype.setupSolver = function () {\n\t\tthis.numbers = [];\n\t\tthis.fixed = [];\n\t\tthis.grid = [];\n\t\tfor (var i = 0; i < this.originalGrid.length; i++) {\n\t\t\tthis.fixed[i] = [];\n\t\t\tthis.grid[i] = [];\n\t\t\tfor (var j = 0; j < this.originalGrid.length; j++) {\n\t\t\t\tvar num = this.originalGrid[i][j];\n\t\t\t\tthis.grid[i][j] = num;\n\t\t\t\tthis.fixed[i][j] = false;\n\t\t\t\tthis.numbers[num] = { x: j, y: i };\n\t\t\t}\n\t\t}\n\t}\n\n\tNPuzzleSolver.prototype.solve = function () {\n\t\tthis.setupSolver();\n\t\ttry {\n\t\t\tthis.solveGrid(this.grid.length);\n\t\t} catch (err) {\n\t\t\tconsole.log(err.message);\n\t\t\treturn null;\n\t\t}\n\t\treturn this.solution;\n\t}\n\n\tNPuzzleSolver.prototype.solveGrid = function (size) {\n\t\tif (size > 2) {\n\t\t\t// pattern solve nxn squares greater than 2x2\n\t\t\tthis.solveRow(size); // solve the upper row first\n\t\t\tthis.solveColumn(size); // solve the left column next\n\t\t\tthis.solveGrid(size - 1); // now we can solve the sub (n-1)x(n-1) puzzle\n\t\t} else if (size == 2) {\n\t\t\tthis.solveRow(size); // solve the row like normal\n\t\t\t// rotate last two numbers if they arent in place\n\t\t\tif (this.grid[this.grid.length - 1][this.grid.length - size] === \"\") {\n\t\t\t\tthis.swapE({ x: this.grid.length - 1, y: this.grid.length - 1 });\n\t\t\t}\n\t\t} // smaller than 2 is solved by definition\n\t}\n\n\tNPuzzleSolver.prototype.solveRow = function (size) {\n\t\tconsole.log(this.numbers[\"\"]);\n\t\tvar rowNumber = this.grid.length - size;\n\t\t// using row number here because this is also our starting column\n\t\tfor (var i = rowNumber; i < this.grid.length - 2; i++) {\n\t\t\tvar number = rowNumber * this.grid.length + (i + 1); // calculate the number that is suppose to be at this position\n\t\t\tthis.moveNumberTowards(number, { x: i, y: rowNumber });\n\t\t\tthis.fixed[rowNumber][i] = true;\n\t\t}\n\t\tvar secondToLast = rowNumber * this.grid.length + this.grid.length - 1;\n\t\tvar last = secondToLast + 1;\n\t\t// position second to last number\n\t\tthis.moveNumberTowards(secondToLast, { x: this.grid.length - 1, y: rowNumber });\n\t\t// position last number\n\t\tthis.moveNumberTowards(last, { x: this.grid.length - 1, y: rowNumber + 1 });\n\t\t// double check to make sure they are in the right position\n\t\tif (this.numbers[secondToLast].x != this.grid.length - 1 || this.numbers[secondToLast].y != rowNumber ||\n\t\t\tthis.numbers[last].x != this.grid.length - 1 || this.numbers[last].y != rowNumber + 1) {\n\t\t\t// the ordering has messed up\n\t\t\tthis.moveNumberTowards(secondToLast, { x: this.grid.length - 1, y: rowNumber });\n\t\t\tthis.moveNumberTowards(last, { x: this.grid.length - 2, y: rowNumber });\n\t\t\tthis.moveEmptyTo({ x: this.grid.length - 2, y: rowNumber + 1 });\n\t\t\t// the numbers will be right next to each other\n\t\t\tvar pos = { x: this.grid.length - 1, y: rowNumber + 1 }; // square below last one in row\n\t\t\tvar moveList = [\"ul\", \"u\", \"\", \"l\", \"dl\", \"d\", \"\", \"l\", \"ul\", \"u\", \"\", \"l\", \"ul\", \"u\", \"\", \"d\"];\n\t\t\tthis.applyRelativeMoveList(pos, moveList);\n\t\t\t// now we reversed them, the puzzle is solveable!\n\t\t}\n\t\t// do the special\n\t\tthis.specialTopRightRotation(rowNumber);\n\t\t// now the row has been solved :D\n\t}\n\n\tNPuzzleSolver.prototype.solveColumn = function (size) {\n\t\tvar colNumber = this.grid.length - size;\n\t\t// use column number as this is the starting row\n\t\tfor (var i = colNumber; i < this.grid.length - 2; i++) {\n\t\t\tvar number = i * this.grid.length + 1 + colNumber;\n\t\t\tthis.moveNumberTowards(number, { x: colNumber, y: i });\n\t\t\tthis.fixed[i][colNumber] = true;\n\t\t}\n\t\tvar secondToLast = (this.grid.length - 2) * this.grid.length + 1 + colNumber;\n\t\tvar last = secondToLast + this.grid.length;\n\t\t// position second to last number\n\t\tthis.moveNumberTowards(secondToLast, { x: colNumber, y: this.grid.length - 1 });\n\t\t// position last number\n\t\tthis.moveNumberTowards(last, { x: colNumber + 1, y: this.grid.length - 1 });\n\n\t\t// double check to make sure they are in the right position\n\t\tif (this.numbers[secondToLast].x != colNumber || this.numbers[secondToLast].y != this.grid.length - 1 ||\n\t\t\tthis.numbers[last].x != colNumber + 1 || this.numbers[last].y != this.grid.length - 1) {\n\t\t\t// this happens because the ordering of the two numbers is reversed, we have to reverse them\n\t\t\tthis.moveNumberTowards(secondToLast, { x: colNumber, y: this.grid.length - 1 });\n\t\t\tthis.moveNumberTowards(last, { x: colNumber, y: this.grid.length - 2 });\n\t\t\tthis.moveEmptyTo({ x: colNumber + 1, y: this.grid.length - 2 });\n\t\t\t// the numbers will be stacked and the empty should be to the left of the last number\n\t\t\tvar pos = { x: colNumber + 1, y: this.grid.length - 1 };\n\t\t\tvar moveList = [\"ul\", \"l\", \"\", \"u\", \"ur\", \"r\", \"\", \"u\", \"ul\", \"l\", \"\", \"u\", \"ul\", \"l\", \"\", \"r\"];\n\t\t\tthis.applyRelativeMoveList(pos, moveList);\n\t\t\t// now the order has been officially reversed\n\t\t}\n\n\t\t// do the special\n\t\tthis.specialLeftBottomRotation(colNumber);\n\t\t// now the column is solved\n\t}\n\n\tNPuzzleSolver.prototype.applyRelativeMoveList = function (pos, list) {\n\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\tif (list[i] == \"\") {\n\t\t\t\tthis.swapE(pos);\n\t\t\t} else {\n\t\t\t\tthis.swapE(this.offsetPosition(pos, list[i]));\n\t\t\t}\n\t\t}\n\t}\n\n\tNPuzzleSolver.prototype.moveNumberTowards = function (num, dest) {\n\t\t// dont bother if the piece is in the right place, it can cause odd things to happen with the space\n\t\tif (this.numbers[num].x == dest.x && this.numbers[num].y == dest.y) return; // dont bother\n\n\t\t// choose where we want the empty square\n\t\tthis.makeEmptyNeighborTo(num);\n\t\t// now empty will be next to our number and thats all we need\n\t\tvar counter = 1;\n\t\twhile (this.numbers[num].x != dest.x || this.numbers[num].y != dest.y) {\n\t\t\tvar direction = this.getDirectionToProceed(num, dest);\n\t\t\tif (!this.areNeighbors(num, \"\")) {\n\t\t\t\tthrow \"cannot rotate without empty\";\n\t\t\t}\n\t\t\tif (direction == \"u\" || direction == \"d\") {\n\t\t\t\tthis.rotateVertical(num, (direction == \"u\"));\n\t\t\t} else {\n\t\t\t\tthis.rotateHorizontal(num, (direction == \"l\"));\n\t\t\t}\n\t\t}\n\t}\n\n\tNPuzzleSolver.prototype.rotateHorizontal = function (num, leftDirection) {\n\t\tvar side = (leftDirection) ? \"l\" : \"r\";\n\t\tvar other = (leftDirection) ? \"r\" : \"l\";\n\t\tvar empty = this.numbers[\"\"];\n\t\tvar pos = this.numbers[num];\n\t\tif (empty.y != pos.y) {\n\t\t\t// the empty space is above us\n\t\t\tvar location = (empty.y < pos.y) ? \"u\" : \"d\";\n\t\t\tif (!this.moveable(this.offsetPosition(pos, location + side)) || !this.moveable(this.offsetPosition(pos, location))) {\n\t\t\t\tthis.swapE(this.offsetPosition(pos, location + other));\n\t\t\t\tthis.swapE(this.offsetPosition(pos, other));\n\t\t\t\tthis.proper3By2RotationHorizontal(pos, leftDirection);\n\t\t\t} else {\n\t\t\t\tthis.swapE(this.offsetPosition(pos, location + side));\n\t\t\t\tthis.swapE(this.offsetPosition(pos, side));\n\t\t\t}\n\t\t} else if ((empty.x < pos.x && !leftDirection) || (empty.x > pos.x && leftDirection)) {\n\t\t\t\n\t\t\t// its on the opposite that we want it on\n\t\t\tthis.proper3By2RotationHorizontal(pos, leftDirection);\n\t\t}\n\t\t// now it is in the direction we want to go so just swap\n\t\tthis.swapE(pos);\n\t}\n\n\tNPuzzleSolver.prototype.proper3By2RotationHorizontal = function (pos, leftDirection) {\n\t\tvar side = (leftDirection) ? \"l\" : \"r\";\n\t\tvar other = (leftDirection) ? \"r\" : \"l\";\n\t\tvar location = \"u\"; // assume up as default\n\t\tif (this.moveable(this.offsetPosition(pos, \"d\" + side)) && this.moveable(this.offsetPosition(pos, \"d\")) && this.moveable(this.offsetPosition(pos, \"d\" + other))) {\n\t\t\tlocation = \"d\";\n\t\t} else if (!this.moveable(this.offsetPosition(pos, \"u\" + side)) || !this.moveable(this.offsetPosition(pos, \"u\")) || !this.moveable(this.offsetPosition(pos, \"u\" + other))) {\n\t\t\tthrow \"unable to move up all spots fixed\";\n\t\t}\n\t\tthis.swapE(this.offsetPosition(pos, location + other));\n\t\tthis.swapE(this.offsetPosition(pos, location));\n\t\tthis.swapE(this.offsetPosition(pos, location + side));\n\t\tthis.swapE(this.offsetPosition(pos, side));\n\t}\n\n\tNPuzzleSolver.prototype.rotateVertical = function (num, upDirection) {\n\t\tvar toward = (upDirection) ? \"u\" : \"d\";\n\t\tvar away = (upDirection) ? \"d\" : \"u\";\n\n\t\tvar empty = this.numbers[\"\"];\n\t\tvar pos = this.numbers[num];\n\t\tif (empty.x != pos.x) {\n\t\t\t// its to the right or left\n\t\t\tvar side = (empty.x < pos.x) ? \"l\" : \"r\";\n\t\t\tif (!this.moveable(this.offsetPosition(pos, toward + side)) || !this.moveable(this.offsetPosition(pos, side))) {\n\t\t\t\tthis.swapE(this.offsetPosition(pos, away + side));\n\t\t\t\tthis.swapE(this.offsetPosition(pos, away));\n\t\t\t\tthis.proper2By3RotationVertical(pos, upDirection);\n\t\t\t} else {\n\t\t\t\tthis.swapE(this.offsetPosition(pos, toward + side));\n\t\t\t\tthis.swapE(this.offsetPosition(pos, toward));\n\t\t\t}\n\t\t} else if ((empty.y < pos.y && !upDirection) || (empty.y > pos.y && upDirection)) {\n\t\t\t// its in the opposite direction we want to go\n\t\t\tthis.proper2By3RotationVertical(pos, upDirection);\n\t\t}\n\t\t// now the empty is in the direction we need to go\n\t\t// so just swap with it\n\t\tthis.swapE(pos);\n\t}\n\n\tNPuzzleSolver.prototype.proper2By3RotationVertical = function (pos, upDirection) {\n\t\tvar toward = (upDirection) ? \"u\" : \"d\";\n\t\tvar away = (upDirection) ? \"d\" : \"u\";\n\n\t\tvar side = \"r\"; // default to right column usage\n\t\tif (this.moveable(this.offsetPosition(pos, toward + \"l\")) && this.moveable(this.offsetPosition(pos, \"l\")) && this.moveable(this.offsetPosition(pos, away + \"l\"))) {\n\t\t\tside = \"l\";\n\t\t} else if (!this.moveable(this.offsetPosition(pos, toward + \"r\")) || !this.moveable(this.offsetPosition(pos, \"r\")) || !this.moveable(this.offsetPosition(pos, away + \"r\"))) {\n\t\t\tthrow \"Unable to preform move, the puzzle is quite possibly unsolveable\";\n\t\t}\n\t\tthis.swapE(this.offsetPosition(pos, away + side));\n\t\tthis.swapE(this.offsetPosition(pos, side));\n\t\tthis.swapE(this.offsetPosition(pos, toward + side));\n\t\tthis.swapE(this.offsetPosition(pos, toward));\n\t}\n\n\tNPuzzleSolver.prototype.specialTopRightRotation = function (top) {\n\t\t// lock the two pieces\n\t\tthis.fixed[top][this.grid.length - 1] = true;\n\t\tthis.fixed[top + 1][this.grid.length - 1] = true;\n\t\t// preform the swap\n\t\tvar topRight = { x: this.grid.length - 1, y: top };\n\t\tthis.moveEmptyTo(this.offsetPosition(topRight, \"l\"));\n\t\tthis.swapE(topRight);\n\t\tthis.swapE(this.offsetPosition(topRight, \"d\"));\n\t\t// lock proper pieces and unlock extra from next row\n\t\tthis.fixed[top + 1][this.grid.length - 1] = false;\n\t\tthis.fixed[topRight.y][topRight.x - 1] = true;\n\t}\n\n\tNPuzzleSolver.prototype.specialLeftBottomRotation = function (left) {\n\t\t// lock the two pieces\n\t\tthis.fixed[this.grid.length - 1][left] = true;\n\t\tthis.fixed[this.grid.length - 1][left + 1] = true;\n\t\t// preform the swap\n\t\tvar leftBottom = { x: left, y: this.grid.length - 1 };\n\t\tthis.moveEmptyTo(this.offsetPosition(leftBottom, \"u\"));\n\t\tthis.swapE(leftBottom);\n\t\tthis.swapE(this.offsetPosition(leftBottom, \"r\"));\n\t\t// lock proper pieces and unlock extras from next column\n\t\tthis.fixed[this.grid.length - 1][left + 1] = false;\n\t\tthis.fixed[leftBottom.y - 1][leftBottom.x] = true;\n\t}\n\n\tNPuzzleSolver.prototype.getDirectionToProceed = function (num, dest) {\n\t\tvar cur = this.numbers[num];\n\t\tvar diffx = dest.x - cur.x;\n\t\tvar diffy = dest.y - cur.y;\n\t\t// case 1, we need to move left and are not being blocked\n\t\tif (diffx < 0 && this.moveable({ x: cur.x - 1, y: cur.y })) {\n\t\t\treturn \"l\";\n\t\t}\n\t\t// case 2, we need to move right and are not being blocked\n\t\tif (diffx > 0 && this.moveable({ x: cur.x + 1, y: cur.y })) {\n\t\t\treturn \"r\";\n\t\t}\n\t\t// case 3, we need to move up\n\t\tif (diffy < 0 && this.moveable({ x: cur.x, y: cur.y - 1 })) {\n\t\t\treturn \"u\";\n\t\t}\n\t\t// case 4, we need to move down\n\t\tif (diffy > 0 && this.moveable({ x: cur.x, y: cur.y + 1 })) {\n\t\t\treturn \"d\";\n\t\t}\n\t\tthrow \"There is no valid move, the puzzle was incorrectly shuffled\";\n\t}\n\n\tNPuzzleSolver.prototype.makeEmptyNeighborTo = function (num, boundry) {\n\t\tvar gotoPos = this.numbers[num];\n\t\tvar counter = 1;\n\t\twhile ((this.numbers[\"\"].x != gotoPos.x || this.numbers[\"\"].y != gotoPos.y) && !this.areNeighbors(\"\", num)) {\n\t\t\tthis.movingEmptyLoop(gotoPos);\n\t\t\tcounter++;\n\t\t\tif (counter > 100) {\n\t\t\t\tthrow \"Infinite loop hit while solving the puzzle, it is quite likely this puzzle is invalid\";\n\t\t\t}\n\t\t}\n\t}\n\n\tNPuzzleSolver.prototype.moveEmptyTo = function (pos) {\n\t\t// check to see if the pos is a fixed number\n\t\tif (this.fixed[pos.y][pos.x]) {\n\t\t\tthrow \"cannot move empty to a fixed position\";\n\t\t}\n\t\tvar counter = 1;\n\t\twhile (this.numbers[\"\"].x != pos.x || this.numbers[\"\"].y != pos.y) {\n\t\t\tthis.movingEmptyLoop(pos);\n\t\t\tcounter++;\n\t\t\tif (counter > 100) {\n\t\t\t\tconsole.log(\"problem trying to move the piece\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tNPuzzleSolver.prototype.movingEmptyLoop = function (pos) {\n\t\tvar empty = this.numbers[\"\"];\n\t\tvar diffx = empty.x - pos.x;\n\t\tvar diffy = empty.y - pos.y;\n\t\tif (diffx < 0 && this.canSwap(empty, this.offsetPosition(empty, \"r\"))) {\n\t\t\tthis.swap(empty, this.offsetPosition(empty, \"r\"));\n\t\t} else if (diffx > 0 && this.canSwap(empty, this.offsetPosition(empty, \"l\"))) {\n\t\t\tthis.swap(empty, this.offsetPosition(empty, \"l\"));\n\t\t} else if (diffy < 0 && this.canSwap(empty, this.offsetPosition(empty, \"d\"))) {\n\t\t\tthis.swap(empty, this.offsetPosition(empty, \"d\"));\n\t\t} else if (diffy > 0 && this.canSwap(empty, this.offsetPosition(empty, \"u\"))) {\n\t\t\tthis.swap(empty, this.offsetPosition(empty, \"u\"));\n\t\t}\n\t}\n\n\tNPuzzleSolver.prototype.offsetPosition = function (pos, direction) {\n\t\tif (direction == \"u\") {\n\t\t\treturn { x: pos.x, y: pos.y - 1 };\n\t\t} else if (direction == \"d\") {\n\t\t\treturn { x: pos.x, y: pos.y + 1 };\n\t\t} else if (direction == \"l\") {\n\t\t\treturn { x: pos.x - 1, y: pos.y };\n\t\t} else if (direction == \"r\") {\n\t\t\treturn { x: pos.x + 1, y: pos.y };\n\t\t} else if (direction == \"ul\") {\n\t\t\treturn { x: pos.x - 1, y: pos.y - 1 };\n\t\t} else if (direction == \"ur\") {\n\t\t\treturn { x: pos.x + 1, y: pos.y - 1 };\n\t\t} else if (direction == \"dl\") {\n\t\t\treturn { x: pos.x - 1, y: pos.y + 1 };\n\t\t} else if (direction == \"dr\") {\n\t\t\treturn { x: pos.x + 1, y: pos.y + 1 };\n\t\t}\n\t\treturn pos;\n\t}\n\n\tNPuzzleSolver.prototype.areNeighbors = function (first, second) {\n\t\tvar num1 = this.numbers[first];\n\t\tvar num2 = this.numbers[second];\n\t\treturn (Math.abs(num1.x - num2.x) == 1 && num1.y == num2.y) || (Math.abs(num1.y - num2.y) == 1 && num1.x == num2.x);\n\t}\n\n\tNPuzzleSolver.prototype.moveable = function (pos) {\n\t\treturn this.validPos(pos) && !this.fixed[pos.y][pos.x];\n\t}\n\n\tNPuzzleSolver.prototype.validPos = function (pos) {\n\t\treturn !(pos.x < 0 || pos.x >= this.grid.length || pos.y < 0 || pos.y >= this.grid.length);\n\t}\n\n\tNPuzzleSolver.prototype.canSwap = function (pos1, pos2) {\n\t\tif (!this.validPos(pos1) || !this.validPos(pos2)) {\n\t\t\treturn false;\n\t\t}\n\t\tvar num1 = this.grid[pos1.y][pos1.x];\n\t\tvar num2 = this.grid[pos2.y][pos2.x];\n\t\tif (!this.areNeighbors(num1, num2)) {\n\t\t\treturn false;\n\t\t}\n\t\t// check fixed positions\n\t\treturn !(this.fixed[pos1.y][pos1.x] || this.fixed[pos2.y][pos2.x]);\n\t}\n\n\tNPuzzleSolver.prototype.swapE = function (pos) {\n\t\tthis.swap(this.numbers[\"\"], pos);\n\t}\n\n\tNPuzzleSolver.prototype.swap = function (pos1, pos2) {\n\t\tvar num1 = this.grid[pos1.y][pos1.x];\n\t\tvar num2 = this.grid[pos2.y][pos2.x];\n\t\t// guard against illegal moves\n\t\tif (!this.areNeighbors(num1, num2)) {\n\t\t\tthrow \"These numbers are not neighbors and cannot be swapped\";\n\t\t}\n\t\tif (num1 != \"\" && num2 != \"\") {\n\t\t\tthrow \"You must swap with an empty space\";\n\t\t}\n\t\tvar oldPos1 = this.numbers[num1];\n\t\tthis.numbers[num1] = this.numbers[num2];\n\t\tthis.numbers[num2] = oldPos1;\n\t\tthis.grid[pos1.y][pos1.x] = num2;\n\t\tthis.grid[pos2.y][pos2.x] = num1;\n\t\tthis.solution.push({\n\t\t\tempty: (num1 == \"\") ? pos1 : pos2,\n\t\t\tpiece: (num1 == \"\") ? pos2 : pos1,\n\t\t\tnumber: (num1 == \"\") ? num2 : num1\n\t\t});\n\t}\n\tvar cells = [...document.getElementsByTagName(\"td\")];\n\tarr = [\n\t\t[cells[0].innerHTML, cells[1].innerHTML, cells[2].innerHTML, cells[3].innerHTML],\n\t\t[cells[4].innerHTML, cells[5].innerHTML, cells[6].innerHTML, cells[7].innerHTML],\n\t\t[cells[8].innerHTML, cells[9].innerHTML, cells[10].innerHTML, cells[11].innerHTML],\n\t\t[cells[12].innerHTML, cells[13].innerHTML, cells[14].innerHTML, cells[15].innerHTML],\n\t];\n\tvar solver = new NPuzzleSolver(arr);\n\tvar solution = solver.solve();\n\tvar q = 0;\n\tvar i = 0;\n\tfunction myLoop() {\n\t\tsetTimeout(function () {\n\t\t\tvar cells = [...document.getElementsByTagName(\"td\")];\n\t\t\tif (i == 16) {\n\t\t\t\ti = 0;\n\t\t\t}\n\t\t\tif (cells[i].innerHTML == solution[q].number) {\n\t\t\t\tcells[i].click();\n\t\t\t\ti = 0;\n\t\t\t\tq++;\n\t\t\t}\n\t\t\ti++;\n\n\t\t\tif (q < solution.length && !isStop) {\n\t\t\t\tmyLoop();\n\t\t\t}\n\t\t}, 300);\n\t}\n\tmyLoop();\n}\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });